<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cristal 3D Personalizado</title>
    <style>
        body {
            margin: 0;
            background: black;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        .zoom-info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #FF69B4;
            font-size: 14px;
            opacity: 0.7;
            z-index: 100;
            line-height: 1.4;
        }
        .countdown {
            color: #FF69B4;
            font-size: 14px;
            margin-top: 10px;
        }
        .error-panel, .audio-prompt-panel, .expiration-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            background: rgba(26, 10, 59, 0.95);
            box-shadow: 0 10px 30px rgba(192, 192, 192, 0.3);
            border-radius: 20px;
            z-index: 1000;
            padding: 20px;
            text-align: center;
            color: #e6e6ff;
            backdrop-filter: blur(5px);
        }
        .error-panel header, .audio-prompt-panel header, .expiration-panel header {
            padding: 15px;
            background: linear-gradient(45deg, #c0c0c0, #b300ff);
            color: white;
            font-size: 1.2em;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
        }
        .error-panel button, .audio-prompt-panel button, .expiration-panel button {
            width: 45%;
            padding: 12px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(45deg, #c0c0c0, #b300ff);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            margin: 10px 5px;
        }
        .error-panel button:hover, .audio-prompt-panel button:hover, .expiration-panel button:hover {
            background: linear-gradient(45deg, #a8a8a8, #9900e6);
            transform: scale(1.05);
        }
        .error-panel .error, .expiration-panel .error {
            color: #b300ff;
            background: rgba(179, 0, 255, 0.2);
            font-size: 1em;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        .audio-prompt-panel p {
            font-size: 1em;
            margin: 15px 0;
        }
        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            color: #e6e6ff;
            font-size: 1.2em;
            text-align: center;
        }
        .loader-circle {
            width: 50px;
            height: 50px;
            border: 5px solid #FF69B4;
            border-top: 5px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loader-text {
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(179, 0, 255, 0.7);
        }
        .audio-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }
        .audio-control button {
            padding: 8px 12px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(45deg, #c0c0c0, #b300ff);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            font-size: 0.9em;
        }
        .audio-control button:hover {
            background: linear-gradient(45deg, #a8a8a8, #9900e6);
            transform: scale(1.05);
        }
        .countdown-timer {
            color: #FF69B4;
            font-size: 12px;
            opacity: 0.7;
            text-align: right;
        }
        .mobile-controls {
            position: fixed;
            bottom: 5vw;
            left: 50%;
            transform: translateX(-50%);
            width: 90vw;
            max-width: 400px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .mobile-controls div {
            background: rgba(26, 10, 59, 0.8);
            padding: 10px;
            border-radius: 12px;
            color: #e6e6ff;
            font-size: 14px;
            text-align: center;
        }
        .mobile-controls input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }
        .mobile-controls input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: linear-gradient(90deg, #c0c0c0, #b300ff);
            border-radius: 4px;
        }
        .mobile-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #e6e6ff;
            border-radius: 50%;
            margin-top: -6px;
            cursor: pointer;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 600px) {
            .error-panel, .audio-prompt-panel, .expiration-panel {
                width: 95vw;
            }
            .error-panel header, .audio-prompt-panel header, .expiration-panel header {
                font-size: 1em;
            }
            .error-panel button, .audio-prompt-panel button, .expiration-panel button {
                font-size: 0.9em;
                padding: 10px;
            }
            .loader-text {
                font-size: 1em;
            }
            .loader-circle {
                width: 40px;
                height: 40px;
                border-width: 4px;
            }
            .audio-control button {
                padding: 6px 10px;
                font-size: 0.8em;
            }
            .countdown-timer {
                font-size: 10px;
            }
            .mobile-controls {
                display: flex;
            }
            .zoom-info {
                display: none;
            }
        }
        @media (orientation: landscape) {
            .mobile-controls {
                top: 3vw;
                bottom: auto;
                width: 80vw;
                max-width: 350px;
                flex-direction: column;
            }
            .mobile-controls div {
                font-size: 13px;
                padding: 8px;
            }
            .mobile-controls input[type="range"]::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
                margin-top: -5px;
            }
        }
    </style>
</head>
<body>
    <div class="zoom-info">
        Rueda del mouse: Zoom<br>
        Click y arrastra: Mover arriba/abajo
        <div class="countdown" id="countdown"></div>
    </div>
    <div class="error-panel" id="errorPanel" style="display: none;">
        <header>Error</header>
        <div class="error" id="errorMessage"></div>
        <button onclick="clearCacheAndReload()">Borrar Cach√© y Reintentar</button>
    </div>
    <div class="audio-prompt-panel" id="audioPromptPanel" style="display: none;">
        <header>Reproducir M√∫sica</header>
        <p>¬øDeseas reproducir la m√∫sica de fondo?</p>
        <button onclick="playAudio()">S√≠</button>
        <button onclick="muteAudio()">No</button>
    </div>
    <div class="expiration-panel" id="expirationPanel" style="display: none;">
        <header>Tiempo Expirado</header>
        <div class="error">‚è∞ ¬°El tiempo se acab√≥! Crea un nuevo enlace.</div>
        <button onclick="createNewLink()">Ok</button>
    </div>
    <div class="loader" id="loader">
        <div class="loader-circle"></div>
        <div class="loader-text">Cargando...</div>
    </div>
    <div class="audio-control" id="audioControl" style="display: none;">
        <button id="audioToggle" onclick="toggleAudio()">üîä</button>
    </div>
    <div class="mobile-controls" id="mobileControls">
        <div>
            Zoom
            <input type="range" id="zoomSlider" min="0.1" max="20" step="0.1" value="5">
        </div>
        <div>
            Mover Arriba/Abajo
            <input type="range" id="moveSlider" min="-2" max="2" step="0.01" value="0">
        </div>
    </div>
    <audio id="backgroundMusic" loop>
        <source src="mus/1.mp4" type="audio/mp4">
    </audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const nombrePlaneta = "MI PRINCESA";
        const frasesGirando = [
            '¬°Te amo demasiado!', 'eres mi universo', 'siempre te amare','nunca olvides que te quiero','mi mujer'
        ];
        const fotosGirando = [
    'IMG-20250827-WA0756.jpg',
    'IMG-20250831-WA0212.jpg',
    'IMG-20250901-WA0083.jpg',
    'Medall√≥n_1756688570436_76.jpg',
    'Captura de pantalla_20250817-215411.png'
];

const estrellaFugaz = 'IMG-20250901-WA0083.jpg';
const defaultTextureUrl = 'IMG-20250901-WA0083.jpg';
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        // OPTIMIZACI√ìN: Reducir el Pixel Ratio para m√≥viles para mejorar el rendimiento.
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const audio = document.getElementById('backgroundMusic');
        const audioControl = document.getElementById('audioControl');
        const audioToggle = document.getElementById('audioToggle');
        const audioPromptPanel = document.getElementById('audioPromptPanel');
        const expirationPanel = document.getElementById('expirationPanel');
        window.toggleAudio = function() {
            audio.muted = !audio.muted;
            audioToggle.textContent = audio.muted ? 'üîá' : 'üîä';
        };
        window.playAudio = function() {
            audio.play().catch(error => {
                console.error('Error al reproducir audio:', error);
            });
            audioControl.style.display = 'block';
            audioPromptPanel.style.display = 'none';
        };
        window.muteAudio = function() {
            audio.muted = true;
            audioToggle.textContent = 'üîá';
            audioControl.style.display = 'block';
            audioPromptPanel.style.display = 'none';
        };
        window.createNewLink = function() {
            window.location.href = 'https://josegmo.github.io/Pantalla-universo-/';
        };
        const radius = 1;
        // OPTIMIZACI√ìN: Reducir el n√∫mero de c√≠rculos de texto y objetos para mejorar el rendimiento
        const numCircles = isMobile ? 15 : 20;
        const namesPerCircle = isMobile ? 20 : 30;
        const textSize = isMobile ? 0.025 : 0.02;
        const textMeshes = [];
        const ringGroups = [];
        let shootingStar = null;
        let cometImage = null;
        let flashPlane = null;
        let eventTriggered = false;
        let eventStartTime = 0;
        let isLoading = false;
        const crystalGeometry = new THREE.OctahedronGeometry(0.5, 1);
        const planeHeight = 0.08;
        const planeWidth = planeHeight * (60 / 100);
        const cometGeometry = new THREE.PlaneGeometry(planeWidth * 10, planeHeight * 10);
        const flashGeometry = new THREE.PlaneGeometry(30, 30);
        const starCount = isMobile ? 500 : 1000;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 200;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            const color = new THREE.Color().setHSL(Math.random(), 0.5, 0.7);
            starColors[i * 3] = color.r;
            starColors[i * 3 + 1] = color.g;
            starColors[i * 3 + 2] = color.b;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ vertexColors: true, size: isMobile ? 0.03 : 0.05 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        const auroraGeometry = new THREE.PlaneGeometry(200, 100);
        const auroraMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0.0 } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }
                float noise(vec2 p){
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    float a = rand(i);
                    float b = rand(i + vec2(1.0, 0.0));
                    float c = rand(i + vec2(0.0, 1.0));
                    float d = rand(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                void main() {
                    vec2 p = vUv * vec2(1.0, 5.0) + vec2(0.0, time * 0.1);
                    float n = noise(p * 4.0);
                    float intensity = sin(vUv.y * 3.1416) * n;
                    vec3 color = mix(vec3(0.0, 0.8, 0.2), vec3(0.8, 0.0, 0.8), intensity);
                    gl_FragColor = vec4(color, intensity * 0.5);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);
        aurora.position.z = -50;
        aurora.visible = !isMobile;
        scene.add(aurora);
        const lights = [];
        for (let i = 0; i < 2; i++) {
            const light = new THREE.PointLight(0xFFFFFF, 0.5, 50);
            light.position.set(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            );
            scene.add(light);
            lights.push(light);
        }
        const glowShaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                glowColor: { value: new THREE.Color(0xFFFFFF) },
                accentColor: { value: new THREE.Color(0xFFFF99) },
                glowIntensity: { value: isMobile ? 1.5 : 2.0 },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                uniform vec3 accentColor;
                uniform float glowIntensity;
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    float intensity = pow(0.9 - dot(vNormal, vec3(0, 0, 1)), 2.0) * glowIntensity;
                    float pulse = 0.5 + 0.5 * abs(sin(time * 4.0));
                    vec3 color = mix(glowColor, accentColor, 0.2);
                    gl_FragColor = vec4(color * pulse, 1.0) + vec4(color * intensity * 2.0, 1.0);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        const imageShaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: null },
                glowColor: { value: new THREE.Color(#FFB6C1) },
                accentColor: { value: new THREE.Color(0xFFFF99) },
                glowIntensity: { value: isMobile ? 1.0 : 1.5 },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                uniform vec3 glowColor;
                uniform vec3 accentColor;
                uniform float glowIntensity;
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec4 texColor = texture2D(map, vUv);
                    float edge = max(abs(vUv.x - 0.5), abs(vUv.y - 0.5));
                    float glow = pow(edge, 2.0) * glowIntensity * (0.7 + 0.3 * sin(time * 2.0));
                    vec3 finalColor = texColor.rgb + mix(glowColor, accentColor, 0.3) * glow * 0.5;
                    gl_FragColor = vec4(finalColor, texColor.a);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        const shootingStarMaterial = new THREE.ShaderMaterial({
            uniforms: {
                glowColor: { value: new THREE.Color(#FFB6C1) },
                accentColor: { value: new THREE.Color(0xFFFF99) },
                glowIntensity: { value: isMobile ? 1.5 : 2.0 },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                uniform vec3 accentColor;
                uniform float glowIntensity;
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    float intensity = pow(0.9 - dot(vNormal, vec3(0, 0, 1)), 2.0) * glowIntensity;
                    float pulse = 0.5 + 0.5 * abs(sin(time * 4.0));
                    vec3 color = mix(glowColor, accentColor, 0.2);
                    gl_FragColor = vec4(color * pulse, 1.0) + vec4(color * intensity * 2.0, 1.0);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        const flashMaterial = new THREE.ShaderMaterial({
            uniforms: {
                opacity: { value: 0.0 },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float opacity;
                uniform float time;
                varying vec2 vUv;
                void main() {
                    float intensity = 1.0 - pow(length(vUv - 0.5), 1.2);
                    gl_FragColor = vec4(1.0, 1.0, 0.9, opacity * intensity);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        const ringStarMaterial = new THREE.ShaderMaterial({
            uniforms: {
                glowColor: { value: new THREE.Color(0xFFFFFF) },
                accentColor: { value: new THREE.Color(0xFFFF99) },
                time: { value: 0.0 }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * ${isMobile ? '0.4' : '0.5'};
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                uniform vec3 accentColor;
                uniform float time;
                varying vec3 vColor;
                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    if (dist > 0.5) discard;
                    float intensity = 1.0 - dist / 0.5;
                    float pulse = 0.5 + 0.5 * sin(time * 2.0);
                    vec3 color = mix(glowColor, accentColor, 0.2) * intensity * pulse;
                    gl_FragColor = vec4(color, intensity * 0.6);
                }
            `,
            transparent: true,
            vertexColors: true
        });
        window.clearCacheAndReload = async function() {
            try {
                const cachesKeys = await caches.keys();
                for (const key of cachesKeys) {
                    await caches.delete(key);
                }
                localStorage.clear();
                sessionStorage.clear();
                window.location.reload(true);
            } catch (error) {
                console.error('Error al limpiar cach√©:', error);
                window.location.reload(true);
            }
        };
        function showErrorPanel(message) {
            const errorPanel = document.getElementById('errorPanel');
            const loader = document.getElementById('loader');
            errorPanel.querySelector('#errorMessage').textContent = message;
            errorPanel.style.display = 'block';
            loader.style.display = 'none';
            isLoading = false;
        }
        function createShootingStar() {
            if (shootingStar) scene.remove(shootingStar);
            shootingStar = new THREE.Mesh(crystalGeometry, shootingStarMaterial);
            shootingStar.position.set(10, 10, -10);
            scene.add(shootingStar);
            eventStartTime = time;
            eventTriggered = true;
        }
        function createFlash() {
            if (flashPlane) scene.remove(flashPlane);
            flashPlane = new THREE.Mesh(flashGeometry, flashMaterial);
            flashPlane.position.set(0, 0, -1);
            scene.add(flashPlane);
        }
        function createCometImage() {
            if (cometImage) scene.remove(cometImage);
            const textureLoader = new THREE.TextureLoader();
            const textureUrl = estrellaFugaz.startsWith('data:image/') ? estrellaFugaz : defaultTextureUrl;
            textureLoader.load(textureUrl, (texture) => {
                texture.generateMipmaps = true;
                texture.minFilter = THREE.LinearMipmapLinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                const material = imageShaderMaterial.clone();
                material.uniforms.map.value = texture;
                cometImage = new THREE.Mesh(cometGeometry, material);
                cometImage.position.set(0, 0, 0);
                scene.add(cometImage);
            }, undefined, (error) => {
                console.error('Error al cargar la textura de la estrella fugaz:', error);
            });
        }
        async function cargarTexturas(urls) {
            const textureLoader = new THREE.TextureLoader();
            const texturas = [];
            for (let url of urls) {
                const textureUrl = url.startsWith('data:image/') ? url : defaultTextureUrl;
                try {
                    const texture = await new Promise((resolve, reject) => {
                        textureLoader.load(textureUrl, (tex) => {
                            tex.generateMipmaps = true;
                            tex.minFilter = THREE.LinearMipmapLinearFilter;
                            tex.magFilter = THREE.LinearFilter;
                            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                            resolve(tex);
                        }, undefined, reject);
                    });
                    texturas.push(texture);
                } catch (error) {
                    console.error(`Error al cargar textura ${textureUrl}:`, error);
                    const defaultTexture = await new Promise((resolve, reject) => {
                        textureLoader.load(defaultTextureUrl, (tex) => {
                            tex.generateMipmaps = true;
                            tex.minFilter = THREE.LinearMipmapLinearFilter;
                            tex.magFilter = THREE.LinearFilter;
                            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                            resolve(tex);
                        }, undefined, reject);
                    });
                    texturas.push(defaultTexture);
                }
            }
            return texturas;
        }
        async function iniciarVisualizacion() {
            const loader = document.getElementById("loader");
            const audioPromptPanel = document.getElementById('audioPromptPanel');
            audioPromptPanel.style.display = 'block';
            
            try {
                const texturasGirando = await cargarTexturas(fotosGirando);
                const fontLoader = new THREE.FontLoader();
                fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                    const textGeometry = new THREE.TextGeometry(nombrePlaneta, {
                        font: font,
                        size: textSize,
                        height: 0.001
                    });
                    for (let i = 0; i < numCircles; i++) {
                        const phi = Math.PI * i / (numCircles - 1);
                        const y = Math.cos(phi) * radius;
                        const circleRadius = Math.sin(phi) * radius;
                        for (let j = 0; j < namesPerCircle; j++) {
                            const theta = 2 * Math.PI * j / namesPerCircle;
                            const x = Math.cos(theta) * circleRadius;
                            const z = Math.sin(theta) * circleRadius;
                            const textMesh = new THREE.Mesh(textGeometry, glowShaderMaterial);
                            textMesh.position.set(x, y, z);
                            scene.add(textMesh);
                            textMeshes.push(textMesh);
                        }
                    }
                    for (let i = 0; i < numCircles / 2; i++) {
                        const phi = 2 * Math.PI * i / (numCircles / 2);
                        for (let j = 0; j < namesPerCircle; j++) {
                            const theta = Math.PI * j / (namesPerCircle - 1);
                            const x = Math.sin(theta) * Math.cos(phi) * radius;
                            const y = Math.cos(theta) * radius;
                            const z = Math.sin(theta) * Math.sin(phi) * radius;
                            const textMesh = new THREE.Mesh(textGeometry, glowShaderMaterial);
                            textMesh.position.set(x, y, z);
                            scene.add(textMesh);
                            textMeshes.push(textMesh);
                        }
                    }
                    const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                    const ringRadii = [1.6, 2.1, 2.6, 3.1, 3.6, 4.1, 4.6, 5.1];
                    // OPTIMIZACI√ìN: Reducir la cantidad de part√≠culas, frases y estrellas en los anillos
                    const particlesPerRing = isMobile ? [40, 45, 50, 55, 60, 65, 70, 75] : [60, 70, 80, 90, 100, 110, 120, 130];
                    const phrasesPerRing = isMobile ? [4, 5, 6, 7, 8, 9, 10, 11] : [6, 7, 8, 9, 10, 11, 12, 13];
                    const starsPerRing = isMobile ? [35, 40, 45, 50, 55, 60, 65, 70] : [50, 60, 70, 80, 90, 100, 110, 120];
                    const ringThickness = 0.3;
                    ringRadii.forEach((ringRadius, index) => {
                        const ringGroup = new THREE.Group();
                        const numImages = particlesPerRing[index];
                        const numPhrases = phrasesPerRing[index];
                        const numStars = starsPerRing[index];
                        for (let j = 0; j < numImages; j++) {
                            const theta = 2 * Math.PI * j / numImages;
                            const x = ringRadius * Math.cos(theta);
                            const z = ringRadius * Math.sin(theta);
                            const y = (Math.random() - 0.5) * ringThickness;
                            const textureIndex = j % texturasGirando.length;
                            const material = imageShaderMaterial.clone();
                            material.uniforms.map.value = texturasGirando[textureIndex];
                            const imageMesh = new THREE.Mesh(planeGeometry, material);
                            imageMesh.position.set(x, y, z);
                            imageMesh.rotation.z = Math.PI / 2;
                            ringGroup.add(imageMesh);
                        }
                        for (let j = 0; j < numPhrases; j++) {
                            const theta = 2 * Math.PI * j / numPhrases;
                            const x = ringRadius * Math.cos(theta);
                            const z = Math.sin(theta) * ringRadius;
                            const y = (Math.random() - 0.5) * ringThickness;
                            const phraseIndex = j % frasesGirando.length;
                            const phrase = frasesGirando[phraseIndex];
                            const phraseGeometry = new THREE.TextGeometry(phrase, {
                                font: font,
                                size: textSize * 2,
                                height: 0.001
                            });
                            const phraseMesh = new THREE.Mesh(phraseGeometry, glowShaderMaterial);
                            phraseMesh.position.set(x, y, z);
                            ringGroup.add(phraseMesh);
                        }
                        const starPositions = new Float32Array(numStars * 3);
                        const starColors = new Float32Array(numStars * 3);
                        const starSizes = new Float32Array(numStars);
                        for (let j = 0; j < numStars; j++) {
                            const theta = 2 * Math.PI * j / numStars;
                            const x = ringRadius * Math.cos(theta);
                            const z = Math.sin(theta) * ringRadius;
                            const y = (Math.random() - 0.5) * ringThickness;
                            starPositions[j * 3] = x;
                            starPositions[j * 3 + 1] = y;
                            starPositions[j * 3 + 2] = z;
                            const color = new THREE.Color().setHSL(0, 0, 0.9);
                            starColors[j * 3] = color.r;
                            starColors[j * 3 + 1] = color.g;
                            starColors[j * 3 + 2] = color.b;
                            starSizes[j] = isMobile ? (0.02 + Math.random() * 0.02) : (0.03 + Math.random() * 0.03);
                        }
                        const starGeometry = new THREE.BufferGeometry();
                        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
                        const ringStars = new THREE.Points(starGeometry, ringStarMaterial);
                        ringGroup.add(ringStars);
                        scene.add(ringGroup);
                        ringGroups.push(ringGroup);
                    });
                    loader.style.display = 'none';
                    aurora.visible = true;
                    isLoading = false;
                    let countdown = 20;
                    const countdownElement = document.getElementById('countdown');
                    countdownElement.textContent = `Meteorito en ${countdown} segundos!`;
                    const countdownInterval = setInterval(() => {
                        countdown--;
                        if (countdown >= 0) {
                            countdownElement.textContent = `Meteorito en ${countdown} segundos!`;
                        } else {
                            countdownElement.textContent = '';
                            clearInterval(countdownInterval);
                            createShootingStar();
                        }
                    }, 1000);
                }, undefined, (error) => {
                    showErrorPanel('Error al cargar la fuente. Presiona el bot√≥n para borrar el cach√© y reintentar.');
                });
            } catch (error) {
                showErrorPanel('Error al inicializar la visualizaci√≥n. Presiona el bot√≥n para borrar el cach√© y reintentar.');
            }
        }
        if (!isMobile) {
            let isDragging = false;
            let lastMouseY = 0;
            const maxCameraY = 2;
            let cameraY = 0;
            document.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseY = e.clientY;
            });
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaY = e.clientY - lastMouseY;
                cameraY -= deltaY * 0.01;
                cameraY = Math.max(-maxCameraY, Math.min(maxCameraY, cameraY));
                camera.position.y = cameraY;
                lastMouseY = e.clientY;
            });
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            document.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.02;
                camera.position.z = Math.max(0.1, Math.min(20, camera.position.z));
            }, { passive: false });
        }
        if (isMobile) {
            const zoomSlider = document.getElementById('zoomSlider');
            const moveSlider = document.getElementById('moveSlider');
            zoomSlider.addEventListener('input', () => {
                camera.position.z = parseFloat(zoomSlider.value);
            });
            moveSlider.addEventListener('input', () => {
                camera.position.y = parseFloat(moveSlider.value);
            });
            function adjustMobileControls() {
                const mobileControls = document.getElementById('mobileControls');
                mobileControls.style.transition = 'all 0.2s ease';
                mobileControls.style.display = 'flex';
                if (window.innerWidth > window.innerHeight) {
                    mobileControls.style.top = '3vw';
                    mobileControls.style.bottom = 'auto';
                    mobileControls.style.width = '80vw';
                    mobileControls.style.maxWidth = '350px';
                } else {
                    mobileControls.style.top = 'auto';
                    mobileControls.style.bottom = '5vw';
                    mobileControls.style.width = '90vw';
                    mobileControls.style.maxWidth = '400px';
                }
            }
            window.addEventListener('resize', () => {
                setTimeout(adjustMobileControls, 100);
            });
            window.addEventListener('orientationchange', () => {
                setTimeout(adjustMobileControls, 100);
            });
            adjustMobileControls();
        }
        let time = 0;
        let lastFrameTime = 0;
        const targetFPS = isMobile ? 30 : 60;
        const frameInterval = 1000 / targetFPS;
        function animate(currentTime) {
            if (isMobile && (currentTime - lastFrameTime) < frameInterval) {
                requestAnimationFrame(animate);
                return;
            }
            lastFrameTime = currentTime;
            requestAnimationFrame(animate);
            time += 0.016;
            glowShaderMaterial.uniforms.time.value = time;
            imageShaderMaterial.uniforms.time.value = time;
            shootingStarMaterial.uniforms.time.value = time;
            auroraMaterial.uniforms.time.value = time;
            ringStarMaterial.uniforms.time.value = time;
            if (flashMaterial.uniforms) flashMaterial.uniforms.time.value = time;
            if (!isMobile || time % 0.1 < 0.016) {
                lights.forEach((light, index) => {
                    light.position.x += Math.sin(time * 0.3 + index) * 0.05;
                    light.position.y += Math.cos(time * 0.3 + index) * 0.05;
                });
            }
            // OPTIMIZACI√ìN: Solo aplicar lookAt a los grupos, no a cada malla individual, es m√°s eficiente
            if (!isMobile || time % 0.05 < 0.016) {
                textMeshes.forEach(mesh => {
                    mesh.lookAt(camera.position);
                });
            }
            ringGroups.forEach((group) => {
                group.rotation.y += isMobile ? 0.0005 : 0.001;
                // OPTIMIZACI√ìN: Aplicar la rotaci√≥n del grupo, no de cada hijo. El lookAt individual es muy costoso.
                group.children.forEach(mesh => {
                    mesh.lookAt(camera.position);
                });
            });
            if (cometImage) {
                cometImage.lookAt(camera.position);
                cometImage.position.y = Math.sin(time * 2) * 0.2;
            }
            if (shootingStar && eventTriggered) {
                const elapsed = time - eventStartTime;
                const t = elapsed / 2;
                if (t <= 1) {
                    shootingStar.position.x = 10 * (1 - t);
                    shootingStar.position.y = 10 * (1 - t);
                    shootingStar.position.z = -10 * (1 - t);
                    shootingStar.rotation.x += 0.05;
                    shootingStar.rotation.y += 0.05;
                } else if (!flashPlane) {
                    scene.remove(shootingStar);
                    shootingStar = null;
                    createFlash();
                    createCometImage();
                    flashMaterial.uniforms.opacity.value = 1.0;
                }
            }
            if (flashPlane) {
                const flashTime = time - eventStartTime - 2;
                if (flashTime > 0) {
                    flashMaterial.uniforms.opacity.value = Math.max(0, 1 - flashTime / 2);
                    if (flashTime > 4) {
                        scene.remove(flashPlane);
                        flashPlane = null;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate(performance.now());
        function resizeRenderer() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        }
        window.addEventListener('resize', resizeRenderer);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeRenderer, 100);
        });
        resizeRenderer();
        window.addEventListener('load', () => {
            const loader = document.getElementById("loader");
            loader.style.display = 'flex';
            iniciarVisualizacion();
        });
    </script>
</body>
</html>
